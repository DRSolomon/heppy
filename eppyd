#!/usr/bin/env python

import sys
import ssl
import time
import socket
import asyncore
from pprint import pprint

import Net

SIZE = 4096

def d(a):
    pprint(a)
    exit(1)

class EPP:
    def __init__(self, config):
        self.config = config
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.connect((self.config['host'], self.config['port']))
        self.ssl = ssl.wrap_socket(self.socket,
            keyfile  = self.config['keyfile'],
            certfile = self.config['certfile'],
            ca_certs = self.config['ca_certs'])
        self.greeting = Net.read(self.ssl)
        print(self.greeting)

class oldPP:
    def __init__(self, config):
        self.config = config
        self.connect()

    def connect(self):
        self.epp = EPP(self.config)
        self.greeting = self.epp.greeting

    def command(self, xml):
        res = self.epp.command(xml)
        if not res:
            self.connect()
            res = self.epp.command(xml)
        return res

class REPP(asyncore.dispatcher):
    def __init__(self, config):
        self.config     = config
        self.epp        = EPP(config)
        self.socket     = self.epp.ssl
        self.greeting   = self.epp.greeting
        self.query      = ''
        self.answer     = ''
        self.is_reading = False
        self.has_answer = False

    def command(self, xml):
        self.query      = xml
        self.answer     = 'Answer to: ' + xml[:50]
        self.has_answer = True

    def got_answer(self):
        return self.has_answer

class AsyncServer(asyncore.dispatcher):
    def __init__(self, address, epp):
        self.epp = epp
        self.handler = None
        asyncore.dispatcher.__init__(self)
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.bind(address)
        self.address = self.socket.getsockname()
        self.listen(5)
        return

    def handle_accept(self):
        socket, address = self.accept()
        # We only want to deal with one client at a time
        if self.handler:
            socket.close()
            socket = None
        else:
            self.handler = Handler(socket, address, self)

    def handle_close(self):
        self.handler = None

class Handler(asyncore.dispatcher):
    def __init__(self, socket, address, server):
        self.server  = server
        self.epp     = server.epp
        self.address = address
        self.query   = ''
        self.answer  = ''
        self.length  = None
        self.wait_till = 0

        # Start reading
        self.is_reading = True

        # Create ourselves, but with an already provided socket
        asyncore.dispatcher.__init__(self, socket)

    def readable(self):
        return self.is_ready() and self.is_reading

    def writable(self):
        return self.is_ready() and not self.is_reading and self.got_answer()

    def got_answer(self):
        if self.answer:
            return True
        if self.epp.got_answer():
            self.answer = self.epp.answer
            return True
        return False

    def is_ready(self):
        return time.time()>self.wait_till

    def wait(self, seconds):
        self.wait_till = time.time()+seconds

    def handle_read(self):
        if self.length is None:
            net = self.recv(4)
            self.length = Net.int_from_net(net)-4
        else:
            self.query += self.recv(SIZE)
        if len(self.query)>=self.length:
            self.command(self.query)

    def handle_write(self):
        if self.length is None:
            self.length = len(self.answer) + 4
            self.send(Net.int_to_net(self.length))
        elif self.answer:
            sent = self.send(self.answer)
            self.answer = self.answer[sent:]
        if not self.answer:
            self.handle_close()

    def command(self, cmd):
        print "COMMAND: " + cmd
        cmd = cmd.strip()
        if cmd == 'greeting':
            self.answer = self.epp.greeting
        elif cmd == 'info':
            self.answer = 'eppyd info: ...'
        elif cmd == 'wait':
            self.wait(20)
            self.answer = 'waited 20'
        else:
            self.epp.command(cmd)
            self.answer = ''
        self.is_reading = False
        self.length = None

    def handle_close(self):
        self.close()
        self.server.handler = None

if len(sys.argv)<2:
    d('usage: eppyd port')
port = int(sys.argv[1])

epp = REPP({
    'host':         'ote1.meregistry.net',
    'port':         700,
    'certfile':     'all.pem',
    'keyfile':      'key.pem',
    'ca_certs':     'intermediate.pem',
})

server = AsyncServer(('localhost', port), epp)
asyncore.loop()

